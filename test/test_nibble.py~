"""
Testing methods for converting
nucleotides >> nibble >> numpy array

T-000, C-001, A-010, G-011, N-111

This can help make HDF5 files w/ nucleotide information  slightly more compact

This is pretty inefficient code, but it should be faster than
saving onehot encoded numpy arrays!
"""


import numpy as np
from bitstring import BitArray

nib_dict = { 'T':'0000',
                'C':'0001',
                'A':'0010',
                'G':'0011',
                'N':'0100'}

nib_dict_rev = {0:'T',1:'C',2:'A',3:'G',4:'N'}
        


def main():
    seq = "TTTTTTTTTTTTT"
    print seq
    bin_val =  nuc_to_nibble(seq)
    print bin_val
    rest_seq = nibble_to_nuc(bin_val)
    print rest_seq
    np_seq = nuc_to_uint8_numpy(seq)
    print np_seq
    print np_seq.dtype
    print np_seq[0]

    np_decode = uint8_numpy_to_nucs(np_seq)
    print "Decoded numpy",np_decode
    
def nuc_to_nibble(seq_str):
    bin_seq = '0b'
    for l in seq_str:
        bin_seq += nib_dict[l]
    return bin_seq
    
def nibble_to_nuc(bin_str):
    #Convert a quadbit encoded sequence to a nucleotide sequence
    bitarr = BitArray(bin_str)
    nuc_str = ''
    for quad in bitarr.cut(4):
        nuc_str += nib_dict_rev[quad.uint]
    return nuc_str

def nuc_to_uint8_numpy(seq_str):
    all_bits = BitArray(nuc_to_nibble(seq_str))
    byte_list = []
    for byte in all_bits.cut(8):
        byte_list.append(byte.uint)
    return np.asarray(byte_list,dtype=np.uint8)

def byte_to_nucs(byte):
    b = BitArray(format(byte,'#010b'))
    dinuc = ''
    for l in b.cut(4):
        dinuc += nib_dict_rev[l.uint]
    return dinuc

def uint8_numpy_to_nucs(np_arr):
    byte_list = np_arr.tolist()
    nuc_list = [byte_to_nucs(int(byte)) for byte in byte_list]
    return ''.join(nuc_list)


if __name__ == "__main__":
    main()
